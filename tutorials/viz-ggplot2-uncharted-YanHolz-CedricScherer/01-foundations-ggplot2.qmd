---
title: "Foundations of ggplot2"
format: html
---

## Aesthetics 

**Set** the value outside of aes(). No mapping needed.

**Map** the column inside aes() — without quotation marks.

local vs global vs overwrite mapping

```{r}
library(ggplot2)

# local
ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point(aes(color = drv)) +
  geom_smooth()

# global
ggplot(mpg, aes(
  x = displ, y = hwy,
  color = drv
)) +
  geom_point() +
  geom_smooth()

# overwrite
ggplot(mpg, aes(
  x = displ, y = hwy,
  color = drv
)) +
  geom_point() +
  geom_smooth(color = "black")
```

### Mapping Logical Expressions

In `ggplot2`, you don’t always have to map aesthetics to full variables — you can also use logical expressions to highlight specific subsets of your data.

These expressions return `TRUE` or `FALSE`, and can be used to conditionally control things like `color`, `shape`, or `size`.


```{r}
# numeric
ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point(
    aes(color = hwy > 30)
  )

# categorical
ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point(
    aes(size = class == "suv")
  )

# multiple values
ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point(
    aes(color = class %in% c("suv", "pickup"))
  )
```

### Special Case: group

Sometimes, you want to group your data for plotting — but without directly mapping a variable to a visible aesthetic like color, shape, or linetype. That’s where the group aesthetic comes in.

Think of group as a behind-the-scenes instruction: “Treat these values as belonging together,” even if nothing in the plot visually encodes those groups — and thus, it also doesn't come with a legend.

## Geometric Layers

Every layer expects certain aesthetics to be present. 

- Geometries that require two positions, usually x and y, are the most common case.
- Others need a third aesthetic such as label for geom_text() or fill for geom_tile().
- Some layers are minimalists: for example, geom_bar() only required an x or y position to place the bar — and calculates the height or width, respectively, itself.
- And some demand many more, often specific aesthetics such as additional xend and yend to draw a line with geom_segment() to define start and end coordinates.

Geoms are additive — think of it like building up a painting: first the background, then the foreground, then the annotations.

That means: the order matters too!

### Positions

Examples for geom_area:

- position = "stack" (default)
- position = "identity"

And if you want to compare proportions rather than raw values, there’s a potentially lesser-known gem: `position = "fill"` — this normalizes the areas to show relative shares instead, without the need for pre-calculation!

"dodge" and position_dodge()
"dodge2" or position_dodge2()

## Statistical Layers

We’ll explore how to explicitly control statistical transformations in layers. Understanding the link between geoms and stats — and when to switch or customize them — helps you create clearer, more advanced visualizations.

Every geom also performs a statistical transformation — and the stat argument determines which one. Most of the time, it uses a default silently in the background. But that transformation is always there.

```{r}
# default stat
ggplot(mpg, aes(x = class, y = hwy)) +
  geom_point(
    alpha = .3, size = 3,
    # default: draw data as it is
    stat = "identity"
  )

# custom stat
ggplot(mpg, aes(x = class, y = hwy)) +
  geom_point(
    size = 5,
    # custom: first calculate summary (mean by default)
    stat = "summary"
  )
```

Instead of changing the stat argument in `geom_*()` functions, you can also flip your perspective and start from the transformation itself.

That’s where `stat_*()` functions come in: they do the same work, but from the other direction.

```{r}
# geom approach
ggplot(mpg, aes(y = class)) +
  geom_bar(
    # default transformation:
    # calculate counts per group
    stat = "count"
  )

# stat approach
ggplot(mpg, aes(y = class)) +
  stat_count(
    # default geometry:
    # draw a bar per group
    geom = "bar",
    # these arguments are ignored until
    # you change the geom to point
    shape = "🚗",
    size = 10
  )
```

The geom_*() and stat_*() functions simply have either a fixed geom or stat argument, respectively.

- geom_*(**stat**, data, mapping, position, ...)
- stat_*(**geom**, data, mapping, position, ...)

Ultimately, it’s about perspective: geom_*() and stat_*() are just two sides of the same coin. You’ll likely mostly work with geoms, since they map more directly to visual output. But when you explicitly want to control what happens before drawing — to transform, summarize, or smooth your data —stat_*() layers give you that extra bit of precision.

### Smart Summary Stats

Want to show averages, error bars, or other summaries? `stat_summary()` helps you calculate values on the fly and choose how to draw them.

```{r}
ggplot(mpg, aes(x = class, y = hwy)) +
  stat_summary()
```

By default, stat_summary() calculates the mean and its standard error, and uses a a point and a line to displays the three values for each group.

The main arguments to know:

- fun.data: what to calculate — mean_se by default
- geom: how to draw the result — "pointrange" by default

Note: As we need to pass the function itself, not the returned values, it is specified without parentheses.

```{r}
# mean on top of a boxplot
ggplot(mpg, aes(x = class, y = hwy)) +
  geom_boxplot() +
  stat_summary(
    geom = "point",
    size = 4,
    shape = 23,
    color = "#00978A",
    fill = "#88EBDD",
    stroke = 1.2
  )

# after_stat to access value after calculation
ggplot(mpg, aes(x = class, y = hwy)) +
  geom_hline(yintercept = 20, color = "gray60") +
  geom_boxplot() +
  stat_summary(
    fun = mean,
    geom = "point",
    size = 4,
    shape = 23,
    aes(fill = after_stat(y) > 20),
    stroke = 1.2
  )
```

**Advanced stuff**

Alternatively to using the fun.data argument, which requires three summaries (a data frame with variables ymin, y, and ymax), you can also go the DIY route by specifying indiviual functions for each:

- fun: the center (e.g. mean or median)
- fun.min and fun.max: define the range (e.g. mean ± sd)

```{r}
# mean_sdl() is a handy helper that draws mean ± SD intervals — but by default, it shows mean ± 2 × SD. To change that, we have to use the fun.args argument.
ggplot(mpg, aes(x = class, y = hwy)) +
  stat_summary(
    fun.data = mean_sdl,
    fun.args = list(mult = 1)
  )

# Alternatively, you can pass your own functions — it's a bit more intimidating maybe, but actually not that difficult. This is how you calculate mean ± SD manually.
ggplot(mpg, aes(x = class, y = hwy)) +
  stat_summary(
    fun = mean,
    fun.max = function(y) mean(y) + sd(y),
    fun.min = function(y) mean(y) - sd(y)
  )
```

You’re not limited to ranges or points — you can draw any geom you like.

Let's draw some proper error bars with "caps" by combining apointrange and errorbar geometry (in two separate stat_summary() calls).

But not enough! To be more descriptive, we add another summary layer to enrich the chart with labels showing the average highway miles for each vehicle class 🔥

To access these values, we once again use after_stat(), this time in combination with round() to shorten those long decimal values to a single digit.

```{r}
ggplot(mpg, aes(x = class, y = hwy)) +
  stat_summary(
    geom = "errorbar",
    fun.max = function(y) mean(y) + sd(y),
    fun.min = function(y) mean(y) - sd(y),
    width = .3
  ) +
  stat_summary(
    geom = "point",
    fun = mean,
    size = 2
  ) +
  stat_summary(
    geom = "text",
    fun = mean,
    aes(label = after_stat(round(y, 1))),
    hjust = -0.3
  )
```

### Exercise

1. Boxplot boost

```{r}
ggplot(mpg, aes(x = class, y = hwy)) +
  geom_boxplot() +
  stat_summary(
    geom = "point",
    size = 4,
    color = "red",
    shape = 1,
    stroke = 2
  ) +
  stat_summary(
    fun = min,
    geom = "point",
    shape = 17, # triangle
    size = 3,
    color = "#00978A"
  ) +
  stat_summary(
    fun = max,
    geom = "point",
    shape = 15, # square
    size = 3,
    color = "#00978A"
  )
```

4. A mean treat

```{r}
df <- data.frame(
  year = rep(factor(2018:2024), times = 5),
  scoops = c(180, 190, 160, 175, 200, 210, 195, 70, 75, 60, 65, 70, 78, 73, 40, 50, 45, 48, 60, 66, 58, 120, 140, 130, 185, 160, 175, 230, 80, 95, 85, 88, 110, 120, 105),
  flavor = rep(c("Classic Vanilla", "Chocolate", "Mango Sorbet", "Special Flavor", "Strawberry"), each = 7)
)

ggplot(df, aes(x = flavor, y = scoops)) +
  stat_summary(
    aes(color = flavor),
    geom = "point",
    fun = mean,
    shape = 4,
    stroke = 4,
    size = 6
  ) +
  geom_point(
    aes(fill = flavor),
    shape = 21, size = 3, alpha = 0.5
  ) +
  theme_minimal() +
  # this removes all legends
  theme(legend.position = "none")
```

5. Heatmap mishap

```{r}
set.seed(42)
df <- data.frame(
  subject = sample(c("Math", "Science", "History", "English"), size = 60, replace = TRUE),
  grade = sample(c("A", "B", "C", "D"), size = 60, replace = TRUE),
  n = sample(1:10, size = 60, replace = TRUE) # students in each exam
)

ggplot(df, aes(x = grade, y = subject, z = n)) +
  stat_summary_2d(
    fun = sum,
    color = "white",
    linewidth = 0.6
  )
```
## Coordinate Systems

Coordinate systems determine how data is projected onto the plotting canvas. They influence the layout, orientation, and even the perceived shape of your geometries.

- Linear Coordinates 

These systems maintain the direct, proportional mapping of data values to visual positions, preserving the original geometric shapes and relationships.

- Non-linear Coordinates 

These systems transform the data's geometry by applying transformations that alter shapes, angles, or distances. They are essential for specialized plots like pie charts or maps.

By the way: You can also set just the lower or upper limit and specify the other as NA to use the data’s minimum or maximum, respectively. Give it a try in the example above!

## Scales

Scales determine how raw data gets converted into colors, sizes, axes, and more. They’re the link between data values and their visual representation.

Together, aesthetics and scales form a two-part system:

- aes() maps your data columns to visual properties.
- scale_*() controls how those properties appear in the final plot.

### Controlling Scales

- Changing axis limits — like filtering the data range or capping extreme values
- Switching color palettes — like using custom colors for discrete groups or gradients for continuous data
- Styling axes and legends — like adjusting tick marks, re-labeling categories, or modifying the legend’s appearance
- Transforming the data — like applying a log scale on the y-axis or aggregating values into bins

Most scale_*() functions have share some general arguments:

- name: set a custom axis or legend title
- breaks: define steps to display along the axis or in the legend
- labels: customize the value text on the axis or in a legend

#### Positional Encodings

Here are some common arguments specific to **positional scales**:

- limits: set the value range of the data
- expand: control the padding around the scale limits
- position: move the axis to the "top" or "bottom", "left" or "right"
- transform: apply a transformation to an axis (before plotting!)
- na.translate: whether to include NA as a category for discrete scales
- sec.axis: display a secondary axis for continuous scales

```{r}
# discrete
ggplot(msleep, aes(x = vore, y = sleep_rem)) +
  geom_boxplot() +
  scale_x_discrete(
    # change axis title
    name = "Diet",
    # overwrite labels on x-axis
    labels = c("carni" = "Carnivore", "herbi" = "Herbivore", "insecti" = "Insectivore", "omni" = "Omnivore"),
    # reorder categories
    limits = c("herbi", "omni", "carni", "insecti"),
    # remove unknown group
    na.translate = FALSE,
    # place on the top of the panel
    position = "top"
  )

# continuous
ggplot(msleep, aes(x = vore, y = sleep_rem)) +
  geom_boxplot() +
  scale_y_continuous(
    # change axis title
    name = "Hours of REM sleep",
    # adjust limits (may filter data!)
    limits = c(NA, 3),
    # control padding on bottom and top
    expand = expansion(add = c(.2, .5)),
    # set tick marks
    breaks = c(0, 0.75, 1, 1.25, 1.5, 1.75, 2, 2.25, 3), # custom steps
    # breaks = seq(0, 3, by = 0.5), # regular steps
    # add an additional axis on the right
    sec.axis = dup_axis()
  )
```

#### Visual Encodings

```{r}
# discrete
ggplot(msleep, aes(x = sleep_total, y = sleep_rem)) +
  geom_point(aes(fill = vore, shape = vore), size = 4) +
  scale_fill_discrete(
    # change legend title
    name = "Diet:",
    # apply custom fill colors
    type = c("#d13760", "#00978a", "#663e8e", "#c69612"),
    # overwrite labels in legend
    labels = c("carni" = "Carnivore", "herbi" = "Herbivore", "insecti" = "Insectivore", "omni" = "Omnivore")
  ) +
  # scale_shape() is the default but to set
  # custom shapes, we need scale_shape_manual()
  scale_shape_manual(
    # change legend title
    name = "Diet:",
    # apply custom shapes
    values = 21:24, na.value = 4,
    # overwrite labels in legend
    labels = c("carni" = "Carnivore", "herbi" = "Herbivore", "insecti" = "Insectivore", "omni" = "Omnivore")
  )

# continuous
ggplot(msleep, aes(x = sleep_total, y = sleep_rem)) +
  geom_point(aes(fill = awake, size = awake), shape = 21) +
  scale_fill_continuous(
    # change legend title
    name = "Hours awake:",
    # apply a different (in-built) palette
    type = "viridis", direction = -1,
    # change color for NA category
    na.value = "grey70",
    # add this to merge the 2 legends type
    # guide = guide_legend()
    # set legend steps
    breaks = 1:4*5
  ) +
  scale_size(
    # change legend title
    name = "Hours awake:",
    # adjust bubble sizes
    range = c(1, 4)
  )
```

### Replacing Default Scales

Binning data: group values of a continuous variable into regular "bins" — either along positional scales or for visual aesthetics likefill and size.

```{r}
ggplot(msleep, aes(x = sleep_total, y = sleep_rem)) +
  geom_point(aes(fill = awake, size = awake), shape = 21) +
  scale_fill_binned(
    # change legend title
    name = "Hours awake:",
    # apply a different (in-built) palette
    type = "viridis", direction = -1,
    # change guide to merge legend
    guide = guide_bins()
  ) +
  scale_size_binned(
    # change legend title
    name = "Hours awake:",
    # adjust bubble sizes
    range = c(1, 4)
  )
```

Transforming axes: There are convenient shortcuts for common transformations with preset transform arguments:*_log10(), *_sqrt(), and *_reverse().

```{r}
set.seed(123)
x <- (1:10)*100
dat <- data.frame(x = x, y = rnorm(100, 1000, 250) * x)

ggplot(dat, aes(x = x, y = y)) +
  geom_point() +
  stat_smooth(method = "lm") +
  # apply log transformation to x axis
  scale_x_log10() +
  # revert y axis
  scale_y_reverse()
```

Replacing palettes: Use pre-built functions to apply popular palettes like ColorBrewer and viridis — e.g., *_brewer(), *_distiller(), and *_viridis_c()

```{r}
ggplot(mpg, aes(x = factor(year), y = hwy)) +
  geom_boxplot(aes(fill = drv)) +
  scale_fill_brewer(
    palette = "Set2",
    name = "Drive train"
  )
```

Generating palettes: Not happy with the default palettes for continuous values? Define your own using *_gradient(), *_gradient2(), or *_gradientn().

```{r}
df <- data.frame(x = 0:10, y = -5:5)

ggplot(df, aes(x, y, fill = y)) +
  geom_col(color = "grey30") +
  scale_fill_gradient2(
    low = "#d13760",
    mid = "white",
    high = "#663e8e",
    midpoint = 0,
    name = "Deviance"
  ) +
  geom_hline(yintercept = 0, color = "grey30")
```

1. No guide required

```{r}
library(palmerpenguins) # make penguins data available

# Define label positions and text
position <- data.frame(
  x = c(34, 50, 57),
  y = c(20, 13, 19),
  label = c("Adelie", "Gentoo", "Chinstrap")
)

ggplot(penguins, aes(x = bill_length_mm, y = bill_depth_mm, color = species)) +
  geom_point(aes(size = body_mass_g), alpha = 0.7) +
  geom_text(
    data = position,
    aes(x = x, y = y, label = label, color = label),
    size = 6, fontface = "bold"
  ) +
  scale_color_discrete(guide = "none")
```

6. Double vision done right

```{r}
# Temperature data in Celsius (Barcelona, 2024)
temp_barcelona <- data.frame(
  month = 1:12,
  temp_avg = c(8.3, 9.4, 11.7, 13.3, 16.7, 21.1, 23.9, 24.4, 21.7, 17.2, 12.2,
8.9)
)

ggplot(temp_barcelona, aes(x = month, y = temp_avg)) +
  geom_line() +
  geom_point() +
  scale_y_continuous(
    name = "Temperature (°C)",
    breaks = seq(0, 25, by = 5),
    sec.axis = sec_axis(
      trans = ~ . * 9/5 + 32,
      name = "Temperature (°F)",
      breaks = seq(45, 80, by = 5)
    )
  )
```