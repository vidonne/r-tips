---
title: "Foundations of ggplot2"
format: html
---

## Aesthetics 

**Set** the value outside of aes(). No mapping needed.

**Map** the column inside aes() — without quotation marks.

local vs global vs overwrite mapping

```{r}
library(ggplot2)

# local
ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point(aes(color = drv)) +
  geom_smooth()

# global
ggplot(mpg, aes(
  x = displ, y = hwy,
  color = drv
)) +
  geom_point() +
  geom_smooth()

# overwrite
ggplot(mpg, aes(
  x = displ, y = hwy,
  color = drv
)) +
  geom_point() +
  geom_smooth(color = "black")
```

### Mapping Logical Expressions

In `ggplot2`, you don’t always have to map aesthetics to full variables — you can also use logical expressions to highlight specific subsets of your data.

These expressions return `TRUE` or `FALSE`, and can be used to conditionally control things like `color`, `shape`, or `size`.


```{r}
# numeric
ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point(
    aes(color = hwy > 30)
  )

# categorical
ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point(
    aes(size = class == "suv")
  )

# multiple values
ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point(
    aes(color = class %in% c("suv", "pickup"))
  )
```

### Special Case: group

Sometimes, you want to group your data for plotting — but without directly mapping a variable to a visible aesthetic like color, shape, or linetype. That’s where the group aesthetic comes in.

Think of group as a behind-the-scenes instruction: “Treat these values as belonging together,” even if nothing in the plot visually encodes those groups — and thus, it also doesn't come with a legend.

## Geometric Layers

Every layer expects certain aesthetics to be present. 

- Geometries that require two positions, usually x and y, are the most common case.
- Others need a third aesthetic such as label for geom_text() or fill for geom_tile().
- Some layers are minimalists: for example, geom_bar() only required an x or y position to place the bar — and calculates the height or width, respectively, itself.
- And some demand many more, often specific aesthetics such as additional xend and yend to draw a line with geom_segment() to define start and end coordinates.

Geoms are additive — think of it like building up a painting: first the background, then the foreground, then the annotations.

That means: the order matters too!

### Positions

Examples for geom_area:

- position = "stack" (default)
- position = "identity"

And if you want to compare proportions rather than raw values, there’s a potentially lesser-known gem: `position = "fill"` — this normalizes the areas to show relative shares instead, without the need for pre-calculation!

"dodge" and position_dodge()
"dodge2" or position_dodge2()

## Statistical Layers

We’ll explore how to explicitly control statistical transformations in layers. Understanding the link between geoms and stats — and when to switch or customize them — helps you create clearer, more advanced visualizations.

Every geom also performs a statistical transformation — and the stat argument determines which one. Most of the time, it uses a default silently in the background. But that transformation is always there.

```{r}
# default stat
ggplot(mpg, aes(x = class, y = hwy)) +
  geom_point(
    alpha = .3, size = 3,
    # default: draw data as it is
    stat = "identity"
  )

# custom stat
ggplot(mpg, aes(x = class, y = hwy)) +
  geom_point(
    size = 5,
    # custom: first calculate summary (mean by default)
    stat = "summary"
  )
```

Instead of changing the stat argument in `geom_*()` functions, you can also flip your perspective and start from the transformation itself.

That’s where `stat_*()` functions come in: they do the same work, but from the other direction.

```{r}
# geom approach
ggplot(mpg, aes(y = class)) +
  geom_bar(
    # default transformation:
    # calculate counts per group
    stat = "count"
  )

# stat approach
ggplot(mpg, aes(y = class)) +
  stat_count(
    # default geometry:
    # draw a bar per group
    geom = "bar",
    # these arguments are ignored until
    # you change the geom to point
    shape = "🚗",
    size = 10
  )
```

The geom_*() and stat_*() functions simply have either a fixed geom or stat argument, respectively.

- geom_*(**stat**, data, mapping, position, ...)
- stat_*(**geom**, data, mapping, position, ...)

Ultimately, it’s about perspective: geom_*() and stat_*() are just two sides of the same coin. You’ll likely mostly work with geoms, since they map more directly to visual output. But when you explicitly want to control what happens before drawing — to transform, summarize, or smooth your data —stat_*() layers give you that extra bit of precision.

### Smart Summary Stats

Want to show averages, error bars, or other summaries? `stat_summary()` helps you calculate values on the fly and choose how to draw them.

```{r}
ggplot(mpg, aes(x = class, y = hwy)) +
  stat_summary()
```

By default, stat_summary() calculates the mean and its standard error, and uses a a point and a line to displays the three values for each group.

The main arguments to know:

- fun.data: what to calculate — mean_se by default
- geom: how to draw the result — "pointrange" by default

Note: As we need to pass the function itself, not the returned values, it is specified without parentheses.

```{r}
# mean on top of a boxplot
ggplot(mpg, aes(x = class, y = hwy)) +
  geom_boxplot() +
  stat_summary(
    geom = "point",
    size = 4,
    shape = 23,
    color = "#00978A",
    fill = "#88EBDD",
    stroke = 1.2
  )

# after_stat to access value after calculation
ggplot(mpg, aes(x = class, y = hwy)) +
  geom_hline(yintercept = 20, color = "gray60") +
  geom_boxplot() +
  stat_summary(
    fun = mean,
    geom = "point",
    size = 4,
    shape = 23,
    aes(fill = after_stat(y) > 20),
    stroke = 1.2
  )
```

**Advanced stuff**

Alternatively to using the fun.data argument, which requires three summaries (a data frame with variables ymin, y, and ymax), you can also go the DIY route by specifying indiviual functions for each:

- fun: the center (e.g. mean or median)
- fun.min and fun.max: define the range (e.g. mean ± sd)

```{r}
# mean_sdl() is a handy helper that draws mean ± SD intervals — but by default, it shows mean ± 2 × SD. To change that, we have to use the fun.args argument.
ggplot(mpg, aes(x = class, y = hwy)) +
  stat_summary(
    fun.data = mean_sdl,
    fun.args = list(mult = 1)
  )

# Alternatively, you can pass your own functions — it's a bit more intimidating maybe, but actually not that difficult. This is how you calculate mean ± SD manually.
ggplot(mpg, aes(x = class, y = hwy)) +
  stat_summary(
    fun = mean,
    fun.max = function(y) mean(y) + sd(y),
    fun.min = function(y) mean(y) - sd(y)
  )
```

You’re not limited to ranges or points — you can draw any geom you like.

Let's draw some proper error bars with "caps" by combining apointrange and errorbar geometry (in two separate stat_summary() calls).

But not enough! To be more descriptive, we add another summary layer to enrich the chart with labels showing the average highway miles for each vehicle class 🔥

To access these values, we once again use after_stat(), this time in combination with round() to shorten those long decimal values to a single digit.

```{r}
ggplot(mpg, aes(x = class, y = hwy)) +
  stat_summary(
    geom = "errorbar",
    fun.max = function(y) mean(y) + sd(y),
    fun.min = function(y) mean(y) - sd(y),
    width = .3
  ) +
  stat_summary(
    geom = "point",
    fun = mean,
    size = 2
  ) +
  stat_summary(
    geom = "text",
    fun = mean,
    aes(label = after_stat(round(y, 1))),
    hjust = -0.3
  )
```

### Exercise

1. Boxplot boost

```{r}
ggplot(mpg, aes(x = class, y = hwy)) +
  geom_boxplot() +
  stat_summary(
    geom = "point",
    size = 4,
    color = "red",
    shape = 1,
    stroke = 2
  ) +
  stat_summary(
    fun = min,
    geom = "point",
    shape = 17, # triangle
    size = 3,
    color = "#00978A"
  ) +
  stat_summary(
    fun = max,
    geom = "point",
    shape = 15, # square
    size = 3,
    color = "#00978A"
  )
```

4. A mean treat

```{r}
df <- data.frame(
  year = rep(factor(2018:2024), times = 5),
  scoops = c(180, 190, 160, 175, 200, 210, 195, 70, 75, 60, 65, 70, 78, 73, 40, 50, 45, 48, 60, 66, 58, 120, 140, 130, 185, 160, 175, 230, 80, 95, 85, 88, 110, 120, 105),
  flavor = rep(c("Classic Vanilla", "Chocolate", "Mango Sorbet", "Special Flavor", "Strawberry"), each = 7)
)

ggplot(df, aes(x = flavor, y = scoops)) +
  stat_summary(
    aes(color = flavor),
    geom = "point",
    fun = mean,
    shape = 4,
    stroke = 4,
    size = 6
  ) +
  geom_point(
    aes(fill = flavor),
    shape = 21, size = 3, alpha = 0.5
  ) +
  theme_minimal() +
  # this removes all legends
  theme(legend.position = "none")
```

5. Heatmap mishap

```{r}
set.seed(42)
df <- data.frame(
  subject = sample(c("Math", "Science", "History", "English"), size = 60, replace = TRUE),
  grade = sample(c("A", "B", "C", "D"), size = 60, replace = TRUE),
  n = sample(1:10, size = 60, replace = TRUE) # students in each exam
)

ggplot(df, aes(x = grade, y = subject, z = n)) +
  stat_summary_2d(
    fun = sum,
    color = "white",
    linewidth = 0.6
  )
```